<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Node Connector</title>
		<style>
            /* Basic page setup */
            html, body {
                margin: 0;
                padding: 0;
                overflow: hidden;
                width: 100vw;
                height: 100vh;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            }

            /* Canvas styling */
            #nodeCanvas {
                display: block;
                background-color: #2c3e50;
            }

            /* Controls Panel */
            #controls {
                position: absolute;
                top: 15px;
                left: 15px;
                background-color: rgba(255, 255, 255, 0.9);
                padding: 10px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
                z-index: 10;
                display: flex;
                flex-direction: column;
                gap: 5px;
            }

            #controls button {
                display: block;
                width: 100%;
                padding: 8px 12px;
                border: 1px solid #ccc;
                border-radius: 5px;
                background-color: #f0f0f0;
                cursor: pointer;
                font-weight: bold;
                text-align: left;
            }

            #controls button:hover {
                background-color: #e0e0e0;
            }

            /* Tooltip for hover information */
            #tooltip {
                position: absolute;
                display: none;
                padding: 5px 10px;
                background-color: #34495e;
                color: white;
                border-radius: 4px;
                font-size: 14px;
                pointer-events: none; /* Important: allows clicking through the tooltip */
                z-index: 20;
            }

            /* Modal Styles */
            .modal-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.6);
                display: none; /* Hidden by default */
                justify-content: center;
                align-items: center;
                z-index: 100;
            }

            .modal-content {
                background: white;
                padding: 20px 30px;
                border-radius: 10px;
                box-shadow: 0 5px 15px rgba(0,0,0,0.3);
                width: 380px; /* Use a fixed width to prevent resizing */
                max-width: 90vw;
            }

            .modal-content h2 {
                margin-top: 0;
                color: #2c3e50;
                border-bottom: 1px solid #ccc;
                padding-bottom: 10px;
                margin-bottom: 20px;
            }

            .modal-content label {
                display: block;
                margin-top: 15px;
                margin-bottom: 5px;
                font-weight: bold;
                color: #34495e;
            }

            .modal-content input[type="text"],
            .modal-content input[type="number"],
            .modal-content select {
                width: 100%;
                padding: 8px;
                box-sizing: border-box;
                border: 1px solid #ccc;
                border-radius: 4px;
            }

            /* Customization controls in modals */
            .customization-section {
                display: flex;
                gap: 20px;
                margin-top: 15px;
            }
            .customization-section > div {
                flex: 1;
            }

            .color-picker {
                display: flex;
                gap: 6px;
                align-items: center;
                flex-wrap: wrap;
            }
            .color-swatch {
                width: 24px;
                height: 24px;
                border-radius: 50%;
                cursor: pointer;
                border: 2px solid transparent;
                transition: transform 0.1s ease-in-out;
            }
            .color-swatch.selected {
                border-color: #34495e;
                transform: scale(1.2);
            }


            #armNamesContainer, #editArmList {
                margin-top: 10px;
                max-height: 150px;
                overflow-y: auto;
                padding: 10px;
                border: 1px solid #eee;
                border-radius: 4px;
                background: #fafafa;
            }

            .arm-name-input-group {
                display: flex;
                align-items: center;
                gap: 8px;
                margin-bottom: 8px;
            }
            .arm-name-input-group input {
                flex-grow: 1;
            }
            .arm-name-input-group button {
                padding: 6px;
                font-size: 0.8em;
                line-height: 1;
                background-color: #ecf0f1;
                border: 1px solid #bdc3c7;
                border-radius: 4px;
                cursor: pointer;
            }
            .arm-name-input-group button:hover {
                background-color: #e74c3c;
                color: white;
                border-color: #c0392b;
            }

            .modal-buttons {
                margin-top: 25px;
                display: flex;
                justify-content: flex-end;
                gap: 10px;
            }

            .modal-buttons button {
                padding: 10px 15px;
                border-radius: 5px;
                border: none;
                cursor: pointer;
                font-weight: bold;
                font-size: 1em;
            }

            .modal-buttons .cancel-btn {
                background-color: #f0f0f0;
                border: 1px solid #ccc;
            }
            .modal-buttons .cancel-btn:hover {
                background-color: #e0e0e0;
            }

            .modal-buttons .delete-btn {
                background-color: #e74c3c;
                color: white;
                margin-right: auto; /* Pushes it to the left */
            }
            .modal-buttons .delete-btn:hover {
                background-color: #c0392b;
            }

            /* Primary button style */
            #createNodeConfirmBtn, #editNodeSaveBtn {
                background-color: #3498db;
                color: white;
            }
            #createNodeConfirmBtn:hover, #editNodeSaveBtn:hover {
                background-color: #2980b9;
            }
		</style>
	</head>
	<body>

		<div id="controls">
			<button id="addNodeBtn">Add Node</button>
			<button id="exportBtn">Export JSON</button>
			<button id="importBtn">Import JSON</button>
		</div>

		<div id="tooltip"></div>

		<canvas id="nodeCanvas"></canvas>
		<input type="file" id="importFileInput" style="display: none;" accept=".json">

		<div id="modalOverlay" class="modal-overlay">
			<!-- Create Node Modal -->
			<div id="createNodeModal" class="modal-content">
				<h2>Create New Node</h2>
				<label for="nodeNameInput">Node Name:</label>
				<input type="text" id="nodeNameInput" placeholder="Node name">

				<div class="customization-section">
					<div>
						<label for="nodeColorPicker">Color:</label>
						<div id="nodeColorPicker" class="color-picker"></div>
					</div>
					<div>
						<label for="nodeSizeSelector">Size:</label>
						<select id="nodeSizeSelector"></select>
					</div>
				</div>

				<label>Arms:</label>
				<div id="armNamesContainer"></div>
				<button id="createAddArmBtn" style="width: 100%; margin-top: 10px; padding: 6px;">Add New Arm</button>

				<div class="modal-buttons">
					<button id="createNodeConfirmBtn">Create</button>
					<button id="createNodeCancelBtn" class="cancel-btn">Cancel</button>
				</div>
			</div>

			<!-- Edit Node Modal -->
			<div id="editNodeModal" class="modal-content">
				<h2>Edit Node</h2>
				<label for="editNodeNameInput">Node Name:</label>
				<input type="text" id="editNodeNameInput">

				<div class="customization-section">
					<div>
						<label for="editNodeColorPicker">Color:</label>
						<div id="editNodeColorPicker" class="color-picker"></div>
					</div>
					<div>
						<label for="editNodeSizeSelector">Size:</label>
						<select id="editNodeSizeSelector"></select>
					</div>
				</div>

				<label>Arms:</label>
				<div id="editArmList"></div>
				<button id="editAddArmBtn" style="width: 100%; margin-top: 10px; padding: 6px;">Add New Arm</button>

				<div class="modal-buttons">
					<button id="editNodeDeleteBtn" class="delete-btn">Delete Node</button>
					<button id="editNodeCancelBtn" class="cancel-btn">Cancel</button>
					<button id="editNodeSaveBtn">Save</button>
				</div>
			</div>
		</div>

		<script>
            // ===================================
            // SETUP & CONFIG
            // ===================================
            const canvas = document.getElementById('nodeCanvas');
            const ctx = canvas.getContext('2d');
            const tooltip = document.getElementById('tooltip');

            // --- Modal Elements ---
            const modalOverlay = document.getElementById('modalOverlay');
            const createNodeModal = document.getElementById('createNodeModal');
            const editNodeModal = document.getElementById('editNodeModal');
            const nodeNameInput = document.getElementById('nodeNameInput');
            const armNamesContainer = document.getElementById('armNamesContainer');
            const nodeColorPicker = document.getElementById('nodeColorPicker');
            const nodeSizeSelector = document.getElementById('nodeSizeSelector');
            const editNodeNameInput = document.getElementById('editNodeNameInput');
            const editArmList = document.getElementById('editArmList');
            const editAddArmBtn = document.getElementById('editAddArmBtn');
            const editNodeColorPicker = document.getElementById('editNodeColorPicker');
            const editNodeSizeSelector = document.getElementById('editNodeSizeSelector');

            // --- Drawing constants ---
            const ARM_RADIUS = 8;
            const ARM_STICK_OFFSET = 20; // Extra length of the "stick" from the node's edge
            const NODE_SIZES = { tiny: 10, small: 18, medium: 25, large: 35, huge: 60 };
            const NODE_COLORS = ['#3498db', '#e74c3c', '#2ecc71', '#f1c40f', '#9b59b6', '#1abc9c', '#e67e22', '#95a5a6', '#e91e63', '#607d8b']; // Added Pink and Blue-Grey
            const ARM_COLOR = '#95a5a6'; // Default gray
            const HOVER_ARM_COLOR = '#e74c3c'; // Red, for hovering a connected arm
            const CONNECTED_ARM_COLOR = '#f1c40f'; // Yellow, for hovering an unconnected arm or selected arm
            const CONNECTION_COLOR = '#f1c40f';
            const HIGHLIGHT_COLOR = '#ffffff';

            // ===================================
            // STATE MANAGEMENT
            // ===================================
            let nodes = [];
            let connections = [];
            let nextId = 0;
            let selectedNodeForEdit = null;

            let transform = { x: 0, y: 0, scale: 1 };

            let mouseState = {
                x: 0, y: 0, worldX: 0, worldY: 0,
                isDown: false, draggedNode: null, panStart: null,
                selectedArm: null, hoveredItem: null, downPos: { x: 0, y: 0 }
            };

            // For fixing the modal close bug
            let isMouseDownOnModalOverlay = false;

            // ===================================
            // COORDINATE TRANSFORMATION
            // ===================================
            function updateWorldMouseCoords() {
                mouseState.worldX = (mouseState.x - transform.x) / transform.scale;
                mouseState.worldY = (mouseState.y - transform.y) / transform.scale;
            }

            // ===================================
            // CORE LOGIC (Nodes, Arms, Connections)
            // ===================================
            function createNode(name, armCount, armNames, x, y, color, size) {
                const newNode = {
                    id: nextId++,
                    name: name,
                    x: x, y: y,
                    color: color || NODE_COLORS[0],
                    size: size || 'medium',
                    arms: []
                };
                for (let i = 0; i < armCount; i++) {
                    newNode.arms.push({
                        id: nextId++,
                        parentNodeId: newNode.id,
                        name: armNames[i] || '',
                        angle: (i / armCount) * 2 * Math.PI,
                    });
                }
                nodes.push(newNode);
            }

            function deleteNodeById(nodeId) {
                const nodeIndex = nodes.findIndex(n => n.id === nodeId);
                if (nodeIndex === -1) return;
                const armIdsToDelete = new Set(nodes[nodeIndex].arms.map(a => a.id));
                connections = connections.filter(conn => !armIdsToDelete.has(conn.arm1Id) && !armIdsToDelete.has(conn.arm2Id));
                nodes.splice(nodeIndex, 1);
            }

            function isArmConnected(armId) {
                return connections.some(c => c.arm1Id === armId || c.arm2Id === armId);
            }

            function areNodesConnected(node1Id, node2Id) {
                for (const conn of connections) {
                    const arm1 = findArmById(conn.arm1Id);
                    const arm2 = findArmById(conn.arm2Id);
                    if (!arm1 || !arm2) continue;

                    const p1 = arm1.parentNodeId;
                    const p2 = arm2.parentNodeId;

                    if ((p1 === node1Id && p2 === node2Id) || (p1 === node2Id && p2 === node1Id)) {
                        return true;
                    }
                }
                return false;
            }

            function disconnectArm(armId) {
                connections = connections.filter(c => c.arm1Id !== armId && c.arm2Id !== armId);
            }

            function findArmById(armId) {
                for (const node of nodes) {
                    for (const arm of node.arms) {
                        if (arm.id === armId) return arm;
                    }
                }
                return null;
            }

            function findNodeById(nodeId) {
                return nodes.find(n => n.id === nodeId);
            }

            function getArmWorldPosition(arm) {
                const parentNode = findNodeById(arm.parentNodeId);
                if (!parentNode) return { x: 0, y: 0 };
                let angle = arm.angle;
                const connection = connections.find(c => c.arm1Id === arm.id || c.arm2Id === arm.id);
                if (connection) {
                    const otherArmId = connection.arm1Id === arm.id ? connection.arm2Id : connection.arm1Id;
                    const otherArm = findArmById(otherArmId);
                    if (otherArm) {
                        const otherNode = findNodeById(otherArm.parentNodeId);
                        if (otherNode) angle = Math.atan2(otherNode.y - parentNode.y, otherNode.x - parentNode.x);
                    }
                }
                const nodeRadius = NODE_SIZES[parentNode.size] || NODE_SIZES['medium'];
                const armOffset = nodeRadius + ARM_STICK_OFFSET;
                return {
                    x: parentNode.x + Math.cos(angle) * armOffset,
                    y: parentNode.y + Math.sin(angle) * armOffset
                };
            }

            function recalculateArmAngles(node) {
                const armCount = node.arms.length;
                node.arms.forEach((arm, i) => { arm.angle = (i / armCount) * 2 * Math.PI; });
            }

            // ===================================
            // MODAL & UI HELPER FUNCTIONS
            // ===================================
            function populateColorPicker(container, selectedColor) {
                container.innerHTML = '';
                NODE_COLORS.forEach(color => {
                    const swatch = document.createElement('div');
                    swatch.className = 'color-swatch';
                    swatch.style.backgroundColor = color;
                    swatch.dataset.color = color;
                    if (color === selectedColor) swatch.classList.add('selected');
                    swatch.addEventListener('click', () => {
                        container.querySelector('.selected')?.classList.remove('selected');
                        swatch.classList.add('selected');
                    });
                    container.appendChild(swatch);
                });
            }

            function populateSizeSelector(selectElement, selectedSize) {
                selectElement.innerHTML = '';
                Object.keys(NODE_SIZES).forEach(sizeKey => {
                    const option = document.createElement('option');
                    option.value = sizeKey;
                    option.textContent = sizeKey.charAt(0).toUpperCase() + sizeKey.slice(1);
                    if (sizeKey === selectedSize) option.selected = true;
                    selectElement.appendChild(option);
                });
            }

            function createArmInputGroup(name = '') {
                const armGroup = document.createElement('div');
                armGroup.className = 'arm-name-input-group';
                const input = document.createElement('input');
                input.type = 'text';
                input.placeholder = 'Arm name';
                input.value = name;
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'X';
                deleteBtn.title = 'Delete Arm';
                deleteBtn.onclick = () => armGroup.remove();
                armGroup.appendChild(input);
                armGroup.appendChild(deleteBtn);
                return armGroup;
            }

            function showCreateModal() {
                nodeNameInput.value = '';
                armNamesContainer.innerHTML = ''; // Clear previous arms
                // Add 2 default arms
                armNamesContainer.appendChild(createArmInputGroup());
                armNamesContainer.appendChild(createArmInputGroup());

                populateColorPicker(nodeColorPicker, NODE_COLORS[0]);
                populateSizeSelector(nodeSizeSelector, 'medium');

                modalOverlay.style.display = 'flex';
                createNodeModal.style.display = 'block';
                editNodeModal.style.display = 'none';
                nodeNameInput.focus();
            }

            function populateEditArmListItem(arm, isNew = false) {
                const armGroup = document.createElement('div');
                armGroup.className = 'arm-name-input-group';
                armGroup.dataset.armId = isNew ? `new-${nextId++}` : arm.id;
                const input = document.createElement('input');
                input.type = 'text';
                input.value = arm.name;
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'X';
                deleteBtn.title = 'Delete Arm';
                deleteBtn.onclick = () => armGroup.remove();
                armGroup.appendChild(input);
                armGroup.appendChild(deleteBtn);
                editArmList.appendChild(armGroup);
            }

            function showEditModal(node) {
                selectedNodeForEdit = node;
                editNodeNameInput.value = node.name;
                populateColorPicker(editNodeColorPicker, node.color);
                populateSizeSelector(editNodeSizeSelector, node.size);
                editArmList.innerHTML = '';
                node.arms.forEach(arm => populateEditArmListItem(arm));
                modalOverlay.style.display = 'flex';
                createNodeModal.style.display = 'none';
                editNodeModal.style.display = 'block';
                editNodeNameInput.focus();
            }

            function hideAllModals() {
                modalOverlay.style.display = 'none';
                selectedNodeForEdit = null;
            }

            // ===================================
            // DATA IMPORT / EXPORT
            // ===================================
            async function exportData() {
                const state = {
                    nodes,
                    connections,
                    nextId,
                    transform
                };
                const jsonString = JSON.stringify(state, null, 2);
                const blob = new Blob([jsonString], { type: "application/json" });

                try {
                    // Modern approach: File System Access API
                    const handle = await window.showSaveFilePicker({
                        suggestedName: `node-map-${new Date().toISOString().slice(0, 10)}.json`,
                        types: [{
                            description: 'JSON File',
                            accept: { 'application/json': ['.json'] },
                        }],
                    });
                    const writable = await handle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                } catch (err) {
                    // If API is not supported or user cancels
                    if (err.name === 'AbortError') {
                        console.log('User cancelled the save dialog.');
                        return;
                    }

                    // Fallback for older browsers
                    console.warn('showSaveFilePicker API not supported, falling back to legacy download.', err);
                    try {
                        const a = document.createElement('a');
                        const url = URL.createObjectURL(blob);
                        a.href = url;
                        a.download = `node-map-${new Date().toISOString().slice(0, 10)}.json`; // Default name
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    } catch(fallbackErr) {
                        console.error('Legacy download method failed.', fallbackErr);
                        alert('Could not save the file.');
                    }
                }
            }

            function importData(event) {
                if (!confirm("This will replace your current canvas. Are you sure?")) {
                    event.target.value = ''; // Reset input
                    return;
                }
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const state = JSON.parse(e.target.result);
                        if (state.nodes && state.connections && state.nextId && state.transform) {
                            nodes = state.nodes;
                            connections = state.connections;
                            nextId = state.nextId;
                            transform = state.transform;
                        } else {
                            alert("Error: Invalid or corrupted file format.");
                        }
                    } catch (err) {
                        alert("Error reading file: " + err.message);
                    } finally {
                        event.target.value = ''; // Reset input to allow re-importing same file
                    }
                };
                reader.readAsText(file);
            }

            // ===================================
            // DRAWING FUNCTIONS
            // ===================================
            function draw() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                ctx.save();
                ctx.translate(transform.x, transform.y);
                ctx.scale(transform.scale, transform.scale);
                ctx.clearRect(-transform.x / transform.scale, -transform.y / transform.scale, canvas.width / transform.scale, canvas.height / transform.scale);


                ctx.strokeStyle = CONNECTION_COLOR;
                ctx.lineWidth = 3 / transform.scale;
                connections.forEach(conn => {
                    const arm1 = findArmById(conn.arm1Id);
                    const arm2 = findArmById(conn.arm2Id);
                    if (arm1 && arm2) {
                        const pos1 = getArmWorldPosition(arm1);
                        const pos2 = getArmWorldPosition(arm2);
                        ctx.beginPath();
                        ctx.moveTo(pos1.x, pos1.y);
                        ctx.lineTo(pos2.x, pos2.y);
                        ctx.stroke();
                    }
                });

                nodes.forEach(node => {
                    const nodeRadius = NODE_SIZES[node.size] || NODE_SIZES['medium'];
                    node.arms.forEach(arm => {
                        const armPos = getArmWorldPosition(arm);
                        ctx.strokeStyle = ARM_COLOR;
                        ctx.lineWidth = 4 / transform.scale;
                        ctx.beginPath();
                        ctx.moveTo(node.x, node.y);
                        ctx.lineTo(armPos.x, armPos.y);
                        ctx.stroke();

                        let armFillColor = ARM_COLOR; // Default is gray
                        if (mouseState.hoveredItem === arm) {
                            if (isArmConnected(arm.id)) {
                                armFillColor = HOVER_ARM_COLOR; // Hovered and connected -> Red
                            } else {
                                armFillColor = CONNECTED_ARM_COLOR; // Hovered and not connected -> Yellow
                            }
                        } else if (mouseState.selectedArm === arm) {
                            // Exception for UX: make the selected arm yellow for feedback
                            armFillColor = CONNECTED_ARM_COLOR;
                        }

                        ctx.fillStyle = armFillColor;
                        ctx.beginPath();
                        ctx.arc(armPos.x, armPos.y, ARM_RADIUS, 0, 2 * Math.PI);
                        ctx.fill();
                    });

                    ctx.fillStyle = node.color;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, nodeRadius, 0, 2 * Math.PI);
                    ctx.fill();
                    if (mouseState.hoveredItem === node || mouseState.draggedNode === node || selectedNodeForEdit === node) {
                        ctx.strokeStyle = HIGHLIGHT_COLOR;
                        ctx.lineWidth = 3 / transform.scale;
                        ctx.stroke();
                    }
                });

                ctx.restore();
                requestAnimationFrame(draw);
            }

            // ===================================
            // EVENT HANDLERS
            // ===================================
            function setupEventListeners() {
                document.getElementById('addNodeBtn').addEventListener('click', showCreateModal);
                document.getElementById('exportBtn').addEventListener('click', exportData);
                document.getElementById('importBtn').addEventListener('click', () => document.getElementById('importFileInput').click());
                document.getElementById('importFileInput').addEventListener('change', importData);

                // FIX: Prevent modal from closing when selecting text and dragging outside.
                modalOverlay.addEventListener('mousedown', (e) => {
                    if (e.target === modalOverlay) {
                        isMouseDownOnModalOverlay = true;
                    }
                });
                modalOverlay.addEventListener('mouseup', (e) => {
                    if (e.target === modalOverlay && isMouseDownOnModalOverlay) {
                        hideAllModals();
                    }
                    isMouseDownOnModalOverlay = false;
                });
                modalOverlay.addEventListener('mouseleave', () => {
                    isMouseDownOnModalOverlay = false;
                });

                document.getElementById('createAddArmBtn').addEventListener('click', () => {
                    armNamesContainer.appendChild(createArmInputGroup());
                });

                document.getElementById('createNodeConfirmBtn').addEventListener('click', () => {
                    const name = nodeNameInput.value.trim();
                    const armNameInputs = armNamesContainer.querySelectorAll('.arm-name-input-group input');
                    const armNames = Array.from(armNameInputs).map(input => input.value.trim()); // Allow empty names
                    const armCount = armNames.length;

                    const color = nodeColorPicker.querySelector('.selected').dataset.color;
                    const size = nodeSizeSelector.value;
                    createNode(name, armCount, armNames, (canvas.width / 2 - transform.x) / transform.scale, (canvas.height / 2 - transform.y) / transform.scale, color, size);
                    hideAllModals();
                });
                document.getElementById('createNodeCancelBtn').addEventListener('click', hideAllModals);

                editAddArmBtn.addEventListener('click', () => { if (selectedNodeForEdit) populateEditArmListItem({ name: '' }, true); });

                document.getElementById('editNodeSaveBtn').addEventListener('click', () => {
                    if (!selectedNodeForEdit) return;
                    selectedNodeForEdit.name = editNodeNameInput.value.trim();
                    selectedNodeForEdit.color = editNodeColorPicker.querySelector('.selected').dataset.color;
                    selectedNodeForEdit.size = editNodeSizeSelector.value;

                    const armElements = editArmList.querySelectorAll('.arm-name-input-group');
                    const updatedArms = [];
                    const armIdsInUI = new Set();
                    armElements.forEach(group => {
                        const idStr = group.dataset.armId;
                        const name = group.querySelector('input').value.trim(); // Allow empty names
                        if (idStr.startsWith('new-')) {
                            const newArm = { id: parseInt(idStr.split('-')[1], 10), parentNodeId: selectedNodeForEdit.id, name, angle: 0 };
                            updatedArms.push(newArm);
                            armIdsInUI.add(newArm.id);
                        } else {
                            const id = parseInt(idStr, 10);
                            const existingArm = selectedNodeForEdit.arms.find(a => a.id === id);
                            if (existingArm) {
                                existingArm.name = name;
                                updatedArms.push(existingArm);
                                armIdsInUI.add(id);
                            }
                        }
                    });
                    selectedNodeForEdit.arms.forEach(arm => { if (!armIdsInUI.has(arm.id)) disconnectArm(arm.id); });
                    selectedNodeForEdit.arms = updatedArms;
                    recalculateArmAngles(selectedNodeForEdit);
                    hideAllModals();
                });

                document.getElementById('editNodeDeleteBtn').addEventListener('click', () => { if (selectedNodeForEdit) { deleteNodeById(selectedNodeForEdit.id); hideAllModals(); } });
                document.getElementById('editNodeCancelBtn').addEventListener('click', hideAllModals);


                canvas.addEventListener('mousedown', e => {
                    mouseState.isDown = true;
                    mouseState.downPos = { x: e.clientX, y: e.clientY };
                    updateWorldMouseCoords();
                    const nodeRadius = (node) => NODE_SIZES[node.size] || NODE_SIZES['medium'];
                    for (const node of nodes) {
                        for (const arm of node.arms) {
                            const armPos = getArmWorldPosition(arm);
                            if (Math.hypot(mouseState.worldX - armPos.x, mouseState.worldY - armPos.y) <= ARM_RADIUS) {
                                if (isArmConnected(arm.id)) {
                                    disconnectArm(arm.id);
                                    mouseState.selectedArm = null;
                                } else if (mouseState.selectedArm) {
                                    const selectedArmParentId = mouseState.selectedArm.parentNodeId;
                                    const clickedArmParentId = arm.parentNodeId;
                                    if (
                                        selectedArmParentId !== clickedArmParentId &&
                                        !isArmConnected(mouseState.selectedArm.id) &&
                                        !areNodesConnected(selectedArmParentId, clickedArmParentId)
                                    ) {
                                        connections.push({ arm1Id: mouseState.selectedArm.id, arm2Id: arm.id });
                                    }
                                    mouseState.selectedArm = null;
                                } else {
                                    mouseState.selectedArm = arm;
                                }
                                return;
                            }
                        }
                    }
                    for (let i = nodes.length - 1; i >= 0; i--) {
                        const node = nodes[i];
                        if (Math.hypot(mouseState.worldX - node.x, mouseState.worldY - node.y) <= nodeRadius(node)) {
                            mouseState.draggedNode = node;
                            mouseState.draggedNode.offsetX = mouseState.worldX - node.x;
                            mouseState.draggedNode.offsetY = mouseState.worldY - node.y;
                            return;
                        }
                    }
                    mouseState.panStart = { x: mouseState.x, y: mouseState.y };
                    mouseState.selectedArm = null;
                });

                canvas.addEventListener('mousemove', e => {
                    mouseState.x = e.clientX;
                    mouseState.y = e.clientY;
                    updateWorldMouseCoords();
                    if (mouseState.draggedNode) {
                        mouseState.draggedNode.x = mouseState.worldX - mouseState.draggedNode.offsetX;
                        mouseState.draggedNode.y = mouseState.worldY - mouseState.draggedNode.offsetY;
                    } else if (mouseState.panStart) {
                        transform.x += mouseState.x - mouseState.panStart.x;
                        transform.y += mouseState.y - mouseState.panStart.y;
                        mouseState.panStart = { x: mouseState.x, y: mouseState.y };
                    }
                    let foundItem = null;
                    const nodeRadius = (node) => NODE_SIZES[node.size] || NODE_SIZES['medium'];
                    for (const node of nodes) {
                        for (const arm of node.arms) {
                            if (Math.hypot(mouseState.worldX - getArmWorldPosition(arm).x, mouseState.worldY - getArmWorldPosition(arm).y) <= ARM_RADIUS) { foundItem = arm; break; }
                        }
                        if(foundItem) break;
                    }
                    if (!foundItem) {
                        for (const node of nodes) {
                            if (Math.hypot(mouseState.worldX - node.x, mouseState.worldY - node.y) <= nodeRadius(node)) { foundItem = node; break; }
                        }
                    }
                    mouseState.hoveredItem = foundItem;

                    // Only show tooltip if the item is hovered and has a name.
                    if (mouseState.hoveredItem && mouseState.hoveredItem.name) {
                        tooltip.style.display = 'block';
                        tooltip.style.left = `${e.clientX + 15}px`;
                        tooltip.style.top = `${e.clientY + 15}px`;
                        tooltip.textContent = mouseState.hoveredItem.name;
                    } else {
                        tooltip.style.display = 'none';
                    }
                });

                canvas.addEventListener('mouseup', e => {
                    if (mouseState.draggedNode && Math.hypot(e.clientX - mouseState.downPos.x, e.clientY - mouseState.downPos.y) < 5) {
                        showEditModal(mouseState.draggedNode);
                    }
                    mouseState.isDown = false; mouseState.draggedNode = null; mouseState.panStart = null;
                });

                canvas.addEventListener('mouseleave', () => {
                    mouseState.isDown = false; mouseState.draggedNode = null; mouseState.panStart = null; tooltip.style.display = 'none';
                });

                canvas.addEventListener('wheel', e => {
                    e.preventDefault();
                    const zoomIntensity = 0.75;
                    const scaleAmount = 1 - e.deltaY * 0.001 * zoomIntensity;
                    const worldXBeforeZoom = (e.clientX - transform.x) / transform.scale;
                    const worldYBeforeZoom = (e.clientY - transform.y) / transform.scale;
                    transform.scale *= scaleAmount;
                    transform.scale = Math.max(0.1, Math.min(transform.scale, 5));
                    const worldXAfterZoom = (e.clientX - transform.x) / transform.scale;
                    const worldYAfterZoom = (e.clientY - transform.y) / transform.scale;
                    transform.x += (worldXAfterZoom - worldXBeforeZoom) * transform.scale;
                    transform.y += (worldYAfterZoom - worldYBeforeZoom) * transform.scale;
                });
            }

            // ===================================
            // INITIALIZATION
            // ===================================
            function init() {
                transform.x = canvas.width / 2;
                transform.y = canvas.height / 2;
                updateWorldMouseCoords();
                setupEventListeners();
                requestAnimationFrame(draw);
            }

            init();
		</script>
	</body>
</html>
